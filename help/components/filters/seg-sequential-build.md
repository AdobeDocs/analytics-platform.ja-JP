---
description: 順次フィルターは、AND または OR の代わりに THEN 演算子を使用して作成されます。 THEN は、1 つのフィルター条件が発生し、続いて別のフィルター条件が発生することを意味します。 デフォルトでは、順次フィルターは、一致するすべてのデータを識別し、「全員を含める」フィルターを表示します。 順次フィルターは、「シーケンスの前のみ」および「シーケンスの後のみ」オプションを使用して、一致するヒットのサブセットにさらにフィルタリングできます。
title: 順次フィルターの作成
feature: Filters
exl-id: 64cb10b5-36f0-42c8-b687-ae5de5ced8b5
source-git-commit: 85abe07d29ad74578aa5bf6a23ae4016b0e9d82f
workflow-type: tm+mt
source-wordcount: '3918'
ht-degree: 65%

---

# 順次フィルターの作成

順次フィルターは、AND または OR の代わりに THEN 演算子を使用して作成されます。 は、1 つのフィルター条件が発生し、その後に別のフィルター条件が続くことを意味します。 デフォルトでは、順次フィルターは、一致するすべてのデータを識別し、「全員を含める」フィルターを表示します。 順次フィルターは、「シーケンスの前のみ」および「シーケンスの後のみ」オプションを使用して、一致するヒットのサブセットにさらにフィルタリングできます。

![](assets/before-after-sequence.png)

以下は、順次セグメント化に関するビデオです。

>[!VIDEO](https://video.tv.adobe.com/v/25405/?quality=12)

## 全員を含む {#include_everyone}

「全員を含める」が設定されているフィルターを作成すると、フィルターによって、指定されたパターンに全体として一致するパスが識別されます。 これは、同じ訪問者が訪問したヒット（ページ A）とヒット（ページ B）を順に検索する基本的なシーケンスフィルターの例です。 フィルターは「全員を含める」に設定されています。

![](assets/filter.png)
![70a875e2-0ef9-4459-8648-77c60081d64d](https://git.corp.adobe.com/storage/user/5902/files/d55be11f-4c4c-4198-bba5-ecad27ebcabf)

| 結果が次の場合： | シーケンス |
|--- | --- |
| 一致する | A、B<br>A、（異なる訪問の） BA、D、B |
| 一致しない | B -> A |

## シーケンスの前のみおよびシーケンスの後のみ {#only_before_after}

オプション **[!UICONTROL シーケンスの前のみ]** および **[!UICONTROL シーケンスの後のみ]** は、指定したシーケンスの前または後のデータのサブセットにフィルターを適用します。

* **シーケンスの前のみ**：シーケンスの前のすべてのヒットおよびシーケンス自体の最初のヒットが含まれます（例 1、3 を参照）。1 つのパスにシーケンスが複数回現れる場合、「シーケンスの前のみ」には、最後のシーケンスの最初のヒットおよびそれ以前のすべてのヒットが含まれます（例 2 を参照）。
* **シーケンスの後のみ**：シーケンスの後のすべてのヒットおよびシーケンス自体の最後のヒットが含まれます（例 1、3 を参照）。1 つのパスにシーケンスが複数回現れる場合、「シーケンスの後のみ」には、最初のシーケンスの最後のヒットおよびそれ以後のすべてのヒットが含まれます（例 2 を参照）。

例えば、B -> D のシーケンスについて考えてみます。3 つのフィルターは、次のようにヒットを識別します。

**例 1：B の次に D が 1 回現れる**

| 例 | A | B | C | D | E | F |
|---|---|---|---|---|---|---|
| 全員を含む | A | B | C | D | E | F |
| シーケンスの前のみ | A | B |  |  |  |  |
| シーケンスの後のみ |  |  |  | D | E | F |

**例 2：B の次に D が複数回現れる**

| 例 | A | B | C | D | B | C | D | E |
|---|---|---|---|---|---|---|---|---|
| 全員を含む | A | B | C | D | B | C | D | E |
| シーケンスの前のみ | A | B | C | D | B |  |  |  |
| シーケンスの後のみ |  |  |  | D | B | C | D | E |

また、この概念をヒットの深さディメンションに当てはめてみましょう。

**例 3：ヒットの深さ 3 の後に 5**

![](assets/hit-depth.png)

## ディメンション制約 {#constraints}

「within」句の「THEN」ステートメントの間に、例えば「within 1 search keyword instance（1 個の検索キーワードのインスタンス内）」や「within 1 eVar 47 instance（1 個の eVar 47 インスタンス内）」というように追加できます。これにより、フィルターがディメンションの 1 つのインスタンス内に制限されます。

ルール間に「Dimension内」句を設定すると、フィルターによって、その句が満たされたシーケンスにデータを制限できます。 制約が「Within 1 page（1 ページ内）」に設定されている以下の例を参照してください。

![](assets/sequence-filter4.png)

| 結果が次の場合： | シーケンス |
|--- |--- |
| 一致する | A -> B |
| 一致しない | A -> C -> B （B は A から 1 ページ以内ではなかったため）<br>**注：** ディメンションの制限を取り除くと、「A -> B」と「A -> C -> B」の両方が一致します。 |

## 単純なページビューシーケンス {#simple_sequence}

あるページを閲覧した後に別のページを閲覧した訪問者を識別します。以前、過去または中間の訪問セッションまたは間に発生したページビューの時間や数に関係なく、ヒットレベルのデータによって、このシーケンスがフィルターされます。

**例**：訪問者がページ A を閲覧し、さらに、同じまたは別の訪問内でページ B を閲覧します。

**使用例**

フィルターの使用例を以下に示します。

1. スポーツサイトの訪問者がフットボールランディングページを閲覧し、その後、バスケットボールランディングページを閲覧しますが、必ずしも同じ訪問であるとは限りません。これは、フットボールシーズン中のフットボールの閲覧者にバスケットボールに関するコンテンツをプッシュするようにキャンペーンに促します。
1. ある自動車小売店では、顧客の忠誠度ページをランディングページとして閲覧し、その後、同じ訪問または別の訪問でビデオページに移動した訪問者間の関係を識別します。

**このフィルターを作成**

2 つのページルールをトップレベルの[!UICONTROL 訪問者]コンテナ内でネストし、[!UICONTROL THEN] 演算子を使用してページヒットを順番に並べます。

![](assets/segment_sequential_1.png)

## 複数の訪問にまたがる訪問者シーケンス {#sequence_across}

キャンペーンからフォールアウトしたが、別のセッションでこのページビューのシーケンスに戻ってきた訪問者を識別します。

**例**：訪問者がある訪問でページ A を閲覧し、その後別の訪問でページ B を閲覧した。

**使用例**

このタイプのフィルターの使用例を以下に示します。

* ニュースサイトのスポーツページを訪問した後、別のセッションでスポーツページを再度訪問します。
* ある衣料品店では、あるセッションでランディングページを閲覧し、さらに、別のセッションでチェックアウトページに直接移動した訪問者間の関係を表示します。

**このフィルターを作成**

次の使用例は、最上位の **[!UICONTROL 訪問者]** コンテナ内に 2 つの **[!UICONTROL 訪問]** コンテナをネストし、[!UICONTROL THEN] 演算子を使用してフィルタを順序付けます。

![](assets/visitor_seq_across_visits.png)

## 混合レベルシーケンス {#mixed_level}

不明な訪問回数の間に 2 つのページを閲覧し、さらに別の訪問で 3 ページ目を閲覧した訪問者を識別します。

**例**：訪問者は 1 回以上の訪問でページ A に続き、ページ B を訪問し、さらに別の訪問でページ C を訪問した。

**使用例**

このタイプのフィルターの使用例を以下に示します。

* 訪問者は、最初にニュースサイトを訪問した後、同じ訪問でスポーツページを閲覧します。さらに、別の訪問でウェザーページを訪問します。
* ある小売店では、メインページの後にマイアカウントページに入る訪問者を定義します。さらに、これらの訪問者は、別の訪問でカートを表示ページを訪問します。

**このフィルターを作成**

1. 左のパネルからトップレベルの「[!UICONTROL 訪問者]」コンテナ内に 2 つのページディメンションをドロップします。
1. これらのページディメンション間に THEN 演算子を追加します。
1. **[!UICONTROL オプション]**／**[!UICONTROL コンテナを追加]**&#x200B;をクリックし、[!UICONTROL 訪問者]レベルの下に[!UICONTROL 訪問]コンテナを追加し、[!UICONTROL THEN] 演算子を使用して順番に並べます。

![](assets/mixed_level_checkpoints.png)

## 集計コンテナ {#aggregate_containers}

[!UICONTROL 訪問者]コンテナ内に[!UICONTROL ヒット]コンテナを複数追加すると、同じタイプのコンテナの間に適切な演算子を使用できます。また、ページ数や訪問回数などのルールやディメンションを使用して、ページビューを定義し、[!UICONTROL ヒット]コンテナ内に順次ディメンションを指定することもできます。ヒットレベルでロジックを適用すると、[!UICONTROL  訪問者 ] コンテナ内の同じヒットレベルで一致を制限および結合して、様々なフィルタータイプを作成できます。

**例**：ページビューのシーケンスの最初のヒット（この例ではページ D）の後で、訪問者がページ A を訪問してから、ページ B またはページ C のいずれかを訪問した（訪問回数は不問）。

**使用例**

このタイプのフィルターの使用例を以下に示します。

* ある訪問でメインランディングページを訪問し、次の訪問で男性衣料品ページを閲覧し、さらに次の訪問で女性または子供のランディングページを閲覧した訪問者を識別します。
* e-zine で、ある訪問でホームページを閲覧し、次の訪問でスポーツページを閲覧し、さらに次の訪問でオピニオンページを閲覧した訪問者を収集します。

**このフィルターを作成**

1. [!UICONTROL 訪問者]コンテナを、トップレベルのコンテナとして選択します。
1. 2 つの[!UICONTROL ヒット]レベルのコンテナを追加します。このとき、ディメンションには、[!UICONTROL AND] や [!UICONTROL OR] 演算子によって同じ[!UICONTROL ヒット]レベルで結合された適切な数値ディメンションを含めます。
1. 同じ[!UICONTROL 訪問]コンテナ内に、別の[!UICONTROL ヒット]コンテナを追加し、[!UICONTROL OR] または [!UICONTROL AND] 演算子で結合された 2 つの追加の[!UICONTROL ヒット]コンテナをネストします。

   [!UICONTROL THEN] 演算子を使用して、ネストされた[!UICONTROL ヒット]コンテナのシーケンスを作成します。

![](assets/aggregate_checkpoints2.png)

## 順次フィルターでの「ネスト」 {#nesting}

チェックポイントを [!UICONTROL  訪問 ] レベルと [!UICONTROL  ヒット ] レベルの両方に配置することで、特定の訪問および特定のヒット内の要件を満たすようにフィルターを制限できます。

**例**：訪問者がページ A に訪問した後、その同じ訪問内でページ B に訪問し、さらに別の訪問でページ C にアクセスした。

**このフィルターを作成**

1. トップレベルの[!UICONTROL 訪問]コンテナで、2 つのページディメンションをドラッグします。
1. 両方のルールを選択し、**[!UICONTROL オプション]**／**[!UICONTROL 選択項目からコンテナを追加]**&#x200B;をクリックし、「[!UICONTROL 訪問]」に変更します。
1. これらのルールを [!UICONTROL THEN] 演算子で結合します。
1. [!UICONTROL 訪問]コンテナのピアとしてヒットコンテナを作成し、ページディメンションをドラッグします。
1. 別の [!UICONTROL THEN] 演算子を追加して、[!UICONTROL 訪問]コンテナ内のネストされたシーケンスを、[!UICONTROL ヒット]コンテナと結合します。

![](assets/nesting_sequential_seg.png)

## ヒットの除外 {#exclude}

「[!UICONTROL 以下を除外する]」ルールを使用して[!UICONTROL 訪問者]、[!UICONTROL 訪問]または[!UICONTROL ヒット]のデータを明示的に除外しない限り、セグメントルールはすべてのデータを含みます。一般的なデータを閉じ、より焦点を当てたフィルターを作成できます。 または、見つかったグループを除外するフィルターを作成して、残りのデータセットを識別できます。例えば、注文を行った成功者を含むルールを作成し、それらの訪問者を除外して「未購入者」を識別するなどです。 ただし、ほとんどの場合は、特定の値を含む対象を識別するために「[!UICONTROL 以下を除外する]」ルールを使用するよりも、広範な値を除外するルールを作成する方が良いでしょう。

次に例を示します。

* **ページの除外**。フィルタールールを使用して、レポートから特定のページ（*`Home Page`* など）を除外し、ページが「ホームページ」に等しいヒットルールを作成してから、除外します。 このルールにより、ホームページを除くすべての値が自動的に含まれるようになります。
* **参照ドメインの除外**。Google.com からの参照ドメインのみ含み、その他のすべての参照ドメインを除外するルールを使用します。
* **非購入者の識別**。注文件数が 1 以上の場合を識別して、その[!UICONTROL 訪問者]を除外します。

[!UICONTROL Exclude] 演算子を使用して、特定の訪問またはヒットが訪問者によって実行されないシーケンスを識別できます。[!UICONTROL  チェックポイントを除外 ] を論理グループに含めることもできます（以下を参照）。

### チェックポイント間の除外 {#exclude_between}

チェックポイントが他の 2 つのチェックポイント間で明示的に発生しなかった訪問者をフィルタリングするロジックを適用します。

**例**：ページ A の後、ページ C を訪問したが、ページ B を訪問しなかった訪問者。

**使用例**

このタイプのフィルターの使用例を以下に示します。

* ライフスタイルページの後、アートページに行かずに、シアターセクションを訪問した訪問者。
* ある自動車販売店では、メインランディングページの後、車両ページに行かずに、キャンペーンに興味なしページに直接移動した訪問者間の関係を表示します。

**このフィルターを作成**

単純な、混合レベルまたはネストされた順次フィルターの場合と同様にフィルターを作成し、コンテナ要素の [!UICONTROL EXCLUDE] 演算子を設定します。 次の例は、3 つの [!UICONTROL  ヒット ] コンテナがキャンバスにドラッグされた集計フィルターで、コンテナロジックの結合に割り当てられた [!UICONTROL THEN] 演算子を使用して、中央のページビューコンテナを除外し、ページ A からページ C に移動した訪問者のみをシーケンスに含めます。

![](assets/exclude_between_checkpoints.png)

### シーケンスの開始時の除外 {#exclude_beginning}

除外チェックポイントが順次フィルターの先頭にある場合、最初の除外されていないヒットの前に除外されたページビューが発生しなかったことが確認されます。

例えば、あるレストランが、メインランディングページを避けて注文ページに直接移動する傾向のあるユーザーを表示したいとします。 このデータを表示するには、ランディングページへのヒットを除外し、順次フィルターに注文ページへのヒットを含めます。

**このフィルターを作成**

トップレベルの訪問者コンテナ内に 2 つの別個のヒットコンテナを作成します。次に、最初のコンテナに対して [!UICONTROL EXCLUDE] 演算子を設定します。

![](assets/exclude_beginning_sequence.png)

### シーケンスの終了時の除外 {#exclude_end}

除外チェックポイントがシーケンスの最後にある場合、訪問者シーケンスが終了するまで、除外されない最後のチェックポイントと訪問者シーケンスの最後の間でチェックポイントは発生しません。

例えば、ある衣料品店が、製品ページを閲覧した後に買い物かごにアクセスしなかったすべての訪問者を表示したいとします。 この例は、訪問者がページ A に移動した後に現在または後続の訪問でページ B に移動しない場合として簡略化できます。

**このフィルターを作成**

2 つの [!UICONTROL  ヒット ] コンテナをキャンバスにドラッグし、[!UICONTROL THEN] 演算子を使用して接続することで、単純なシーケンスフィルターを作成します。 次に、[!UICONTROL EXCLUDE] 演算子をシーケンス内の 2 番目の[!UICONTROL ヒット]コンテナに割り当てます。

![](assets/exclude_end_sequence.png)

## 論理グループコンテナ {#logic_group}

論理グループコンテナは、条件を単一の順次フィルターチェックポイントにグループ化する必要があります。 特別な「論理グループ」コンテナは、順次セグメント化でのみ使用でき、前の順次チェックポイントの後、および後続の順次チェックポイントの前に、条件が満たされるようにします。論理グループチェックポイント内の条件は、どの順序でも満たすことができます。これに対し、非順次コンテナ（ヒット、訪問、訪問者）は、シーケンス全体で条件を満たす必要がないので、THEN 演算子と組み合わせて使用した場合に得られる結果は直観的ではありません。「[!UICONTROL 論理グループ]」コンテナは、*複数のチェックポイントをグループとして*&#x200B;扱うように設計されていますが、グループ化されたチェックポイントの&#x200B;*順序*&#x200B;は指定していません。つまり、そのグループ内のチェックポイントの順序は決まっていません。例えば、[!UICONTROL 訪問者]コンテナを別の[!UICONTROL 訪問者]コンテナ内にネストすることはできません。しかし、代わりに、[!UICONTROL 論理グループ]コンテナを[!UICONTROL 訪問者]コンテナ内にネストし、特定の[!UICONTROL 訪問]レベルおよび[!UICONTROL ヒット]レベルのチェックポイントをそこに含めることができます。

>[!NOTE]
>
>[!UICONTROL  論理グループ ] は、順次フィルターでのみ定義できます。つまり、[!UICONTROL THEN] 演算子が式内で使用されます。

| コンテナの階層 | イラスト | 定義 |
|---|---|---|
| 標準的なコンテナ階層 | ![](assets/nesting_container.png) | [!UICONTROL  訪問者 ] コンテナ内では、[!UICONTROL  訪問 ] コンテナと [!UICONTROL  ヒット ] コンテナが順番にネストされ、ヒット、訪問回数、訪問者に基づいてフィルターが抽出されます。 |
| ロジックコンテナ階層 | ![](assets/logic_group_hierarchy.png) | 標準的なコンテナ階層は、[!UICONTROL 論理グループ]コンテナの外側にも必要です。ただし、[!UICONTROL 論理グループ]コンテナ内部では、チェックポイントの順序や階層を設定する必要はありません。これらのチェックポイントで必要なのは、順序を問わず、訪問者が条件を満たすことです。 |

論理グループは大変な作業に見える場合があります。論理グループの使用方法に関するベストプラクティスを以下に示します。

**論理グループコンテナまたはヒット／訪問コンテナのどちらが適していますか。**
順次チェックポイントをグループ化する場合、「コンテナ」は「論理グループ」になります。ただし、これらの順次チェックポイントが 1 回のヒットまたは訪問の範囲内で発生する必要がある場合は、「ヒット」または「訪問」コンテナが必要です。（もちろん、1 回のヒットが複数のチェックポイントにクレジットを提供しない場合、「ヒット」は順次チェックポイントのグループに対しては意味を持ちません。）

**論理グループは順次フィルターの作成を簡素化しますか？**
はい、できます。次の訪問者のこのフィルターを識別しようとしているとします。**ページ A を閲覧した訪問者が、B、C、D の各ページを閲覧した**

このフィルターは、論理グループコンテナを使用せずに作成できますが、複雑で手間がかかります。 訪問者が表示できるページのシーケンスをすべて指定する必要があります。
* `Visitor Container [Page A THEN Page B THEN Page C THEN Page D] or`
* `Visitor Container [Page A THEN Page B THEN Page D THEN Page C] or`
* `Visitor Container [Page A THEN Page C THEN Page B THEN Page D] or`
* `Visitor Container [Page A THEN Page C THEN Page D THEN Page B] or`
* `Visitor Container [Page A THEN Page D THEN Page B THEN Page C] or`
* `Visitor Container [Page A THEN Page D THEN Page C THEN Page B]`

次に示すように、論理グループコンテナを使用すると、このフィルターを簡単に作成できます。

![](assets/logic-grp-example.png)


### 論理グループフィルターの作成 {#logic_group_filter}

他のコンテナと同様に、[!UICONTROL 論理グループ]コンテナは、[!UICONTROL セグメントビルダー]内から複数の方法で作成できます。[!UICONTROL 論理グループ]コンテナをネストするための推奨される方法は次のとおりです。

1. 左側のウィンドウからディメンション、イベントまたはフィルターをドラッグします。
1. 最上位のコンテナを「[!UICONTROL 訪問者]」コンテナに変更します。
1. デフォルトで挿入される [!UICONTROL AND] または [!UICONTROL OR] 演算子を THEN 演算子に変更します。
1. [!UICONTROL ヒット]コンテナ（ディメンション、イベントまたは項目）を選択し、**[!UICONTROL オプション]**／**[!UICONTROL 選択項目からコンテナを追加]**&#x200B;をクリックします。
1. コンテナアイコンをクリックし、「**[!UICONTROL 論理グループ]**」を選択します。![](assets/logic_group_checkpoints.png)
1. これで、階層に関係なく、[!UICONTROL ヒット]を[!UICONTROL 論理グループ]コンテナ内に設定できました。

### 任意の順序での論理グループのチェックポイント {#any_order}

[!UICONTROL 論理グループ]を使用すると、シーケンスの外部にあるそのグループ内の条件を満たすことができます。これにより、通常の階層に関係なく [!UICONTROL  訪問 ] または [!UICONTROL  ヒット ] コンテナが発生するフィルターを作成できます。

**例**：訪問者はページ A を訪問した後で、ページ B とページ C を任意の順序で訪問した。

**このフィルターを作成**

ページ B および C は、外部「[!UICONTROL 訪問者]」コンテナ内の「[!UICONTROL 論理グループ]」コンテナ内でネストされます。次に、A の「[!UICONTROL ヒット]」コンテナの後に、[!UICONTROL AND] 演算子を使用して識別された B と C の「[!UICONTROL 論理グループ]」コンテナが続きます。ページ B と C は「[!UICONTROL 論理グループ]」内にあるので、シーケンスが定義されるわけではなく、ページ B と C の両方を任意の順序でヒットした場合、引数は true になります。

![](assets/logic_group_any_order2.png)

**別の例**：訪問者は、ページ B またはページ C を訪問してから、ページ A を訪問した。

![](assets/logic_group_any_order3.png)

フィルターは、少なくとも論理グループのチェックポイントの 1 つ（B または C）と一致する必要があります。 また、論理グループの条件は、同じヒットで満たされる場合も、複数のヒットをまたいで満たされる場合もあります。

### 論理グループの最初の一致 {#first_match}

[!UICONTROL 論理グループ]を使用すると、シーケンスの外部にあるそのグループ内の条件を満たすことができます。この順序なしの最初の一致フィルターでは、[!UICONTROL  論理グループ ] ルールがまずページ B またはページ C のページビューとして識別され、次にページ A の必須ビューとして識別されます。

**例**：訪問者は、ページ B または ページ C のどちらかを訪問した後で、ページ A を訪問した。

**このフィルターを作成**

ページ B とページ C のディメンションは[!UICONTROL 論理グループ]コンテナ内にグループ化されます。このコンテナでは [!UICONTROL OR] 演算子が選択されます。次に、[!UICONTROL ヒット]コンテナにページ A が値として表されます。

![](assets/logic_group_1st_match.png)

### 論理グループの除外の AND {#lg_exclude_and}

[!UICONTROL  論理グループ ] を使用してフィルターを作成します。このフィルターでは、複数のページビューが集計され、他のページが明確に欠落している間にヒットする必要があったページが定義されます。****

**例**：訪問者はページ A を訪問し、ページ B または C は明示的に訪問せずに、ページ D をヒットした。

**このフィルターを作成**

このフィルターを作成するには、左側のパネルからDimension、イベントおよび事前定義済みフィルターをドラッグします。 論理グループフィルターの作成の節を参照してください。

「[!UICONTROL 論理グループ]」内で値をネストしてから、「**[!UICONTROL 論理グループ]**」コンテナ内の[!UICONTROL 除外]ボタンをクリックします。

![](assets/logic_exclude_and.png)

### 論理グループの除外の OR {#lg_exclude_or}

[!UICONTROL  論理グループ ] を使用してフィルターを作成します。このフィルターでは、複数のページビューが集計され、他のページが明確に欠落している間にヒットする必要があったページが定義されます。

**例**：ページ A を訪問した訪問者が、ページ A の前にページ B もページ C も訪問していない。

**このフィルターを作成**

最初のページ B とページ C が、除外された「[!UICONTROL 論理グループ]」コンテナで識別されます。その後で、訪問者によるページ A のヒットが続きます。

このフィルターを作成するには、左側のパネルからDimension、イベントおよび事前定義済みセグメントをドラッグします。

「[!UICONTROL 論理グループ]」内で値をネストしてから、「**[!UICONTROL 論理グループ]**」コンテナ内の[!UICONTROL 除外]ボタンをクリックします。

![](assets/logic_exclude_or.png)

## Time-Within フィルターと time-After フィルターの作成 {#time_within_after}

各コンテナのヘッダーに組み込まれた [!UICONTROL Within] および [!UICONTROL After] 演算子を使用して、時間、イベントおよびカウントを定義します。

![](assets/then_within_operators.png)

[!UICONTROL Within] および [!UICONTROL After] コンテナを使用し、精度とカウントを指定することで、一致の範囲を指定した期間に制限できます。[!UICONTROL Within] 演算子は、2 つのチェックポイントの間隔の最大値を指定するために使用します。[!UICONTROL After] 演算子は、2 つのチェックポイントの間隔の最小値を指定するために使用します。

>[!NOTE]
>
>**日」や** 日 **など、類似した名前の要素の間** 評価に違いがあります。 Within と After の時間ベースの定義については、ポップアップ・ウィンドウで最初に表示されたオプションを使用します。
>
>![画像](https://git.corp.adobe.com/storage/user/5902/files/70a875e2-0ef9-4459-8648-77c60081d64d)
>
>「Within」および「After」の次元ベースの定義の場合は、サブメニューの下のオプションを使用します *その他のDimension*:
>
>![画像](https://git.corp.adobe.com/storage/user/5902/files/b808eeb0-5e3f-499b-8096-c7eb0d51c57a)

### After および Within 演算子 {#after_within}

期間は、精度を表す 1 つの大文字の後に、その精度の繰り返し回数を表す数値を記述して指定します。

**[!UICONTROL Within]** はエンドポイントを含みます（エンドポイント以下）。

**[!UICONTROL After]** はエンドポイントを含みません（エンドポイントを超える）。

| 演算子 | 説明 |
|--- |--- |
| AFTER | After 演算子は、2 つのチェックポイントの間隔の最小値を指定するために使用します。「後」の値を設定すると、フィルターが適用されたときに時間制限が開始されます。 例えば、ページ A を訪問しページ B に戻らない訪問者を識別するコンテナに対して After 演算子が設定され、1 日後までページ B に戻らない場合、その日は訪問者がページ A を離れた時点から始まります。 訪問者をフィルターに含めるには、ページ A からページ B を表示するまで、少なくとも 1440 分（1 日）移動する必要があります。 |
| WITHIN | Within 演算子は、2 つのチェックポイントの間隔の最大値を指定するために使用します。例えば、ページ A を訪問し、その後 1 日以内にページ B に戻った訪問者を識別するコンテナに対して Within 演算子が設定されている場合、その日は訪問者がページ A を離れた日から始まります。フィルターに含めるには、訪問者がページ B を開く前の最大時間を 1 日間とします。   訪問者をフィルターに含めるには、ページ A からページ B を表示できるようになってから最大 1440 分（1 日）以内に、ページ B への訪問が発生する必要があります。 |
| AFTER／WITHIN | After と Within の両方の演算子を使用する場合に重要になるのが、両方の演算子が順次的ではなく並行的に開始および終了するという点です。例えば、コンテナをに設定してフィルターを作成した場合：<br>`After = 1 Week(s) and Within = 2 Week(s)`<br> 次に、フィルター内の訪問者を識別する条件は、1 ～ 2 週間のみ満たされます。 最初のページヒットの時点から、両方の条件が適用されます。 |

### After 演算子の使用 {#after}

* After の時間では、年、月、日、時間および分を指定して、一致する訪問を追跡できます。
* After の時間は、このような細かな精度を定義できる唯一のレベルである[!UICONTROL ヒット]コンテナにのみ適用されます。

**例**：訪問者がページ A に訪問し、その 2 週間後以降にページ B に訪問した。

![](assets/time_between_after_operator.png)

**セグメントの作成**：このフィルターは、2 つの [!UICONTROL  ヒット ] コンテナを持つ [!UICONTROL  訪問者 ] コンテナを追加することで作成されます。 これにより、[!UICONTROL THEN] 演算子を設定し、[!UICONTROL AFTER] 演算子のドロップダウンを展開して、週の数値を設定できます。

![](assets/after_operator.png)

**一致する**

「2 週間後」と指定した状態で、ページ A へのヒットが 2019 年 6 月 1 日の 0 時 1 分に発生し、その後、次のページ B へのヒットが 2019 年 6 月 15 日の 0 時 1 分（14 日後）までに発生した場合。

| ヒット A | ヒット B | 一致 |
|--- |--- |--- |
| **A** ヒット：2019 年 6 月 1 日 0 時 1 分 | **B** ヒット：2019 年 6 月 15 日 0 時 1 分 | **一致**：2019 年 6 月 1 日の「後」（2 週間後）に発生しているので、この時間制限は一致すると見なされます。 |
| **A** ヒット：2019 年 6 月 1 日 0 時 1 分 | **B** ヒット：2019 年 6 月 8 日 0 時 1 分、B ヒット：2019 年 6 月 15 日 0 時 1 分 | **一致しない**：ページ B の最初のヒットが、2 週間より後であることを求めている制約と矛盾するので、一致しないと見なされます。 |

### Within 演算子の使用 {#within}

* [!UICONTROL Within] では、年、月、日、時間および分を指定して、一致する訪問を追跡できます。
* [!UICONTROL Within] は、このような細かな精度を定義できる唯一のレベルである[!UICONTROL ヒット]コンテナにのみ適用されます。

>[!TIP]
>
>「within」句の「THEN」ステートメントの間に、例えば「within 1 search keyword instance（1 個の検索キーワードのインスタンス内）」や「within 1 eVar 47 instance（1 個の eVar 47 インスタンス内）」というように追加できます。これにより、フィルターがディメンションの 1 つのインスタンス内に制限されます。

**例**：ページ A に訪問した訪問者が、5 分以内にページ B を訪問した。

![](assets/time_between_within_operator.png)

**フィルターの作成**：このフィルターを作成するには、[!UICONTROL  訪問者 ] コンテナを追加し、2 つの [!UICONTROL  ヒット ] コンテナでドラッグします。 次に、[!UICONTROL THEN] 演算子を設定し、[!UICONTROL AFTER] 演算子のドロップダウンを展開して、間隔（ヒット、ページビュー、訪問、分、時、日、週、月、四半期または年）を設定できます。

![](assets/within_operator.png)

**一致する**

この時間制限以内に一致が発生する必要があります。式を指定して、訪問者のページ A へのヒットが 0 時 1 分に発生した場合、その後のページ B へのヒットが 0 時 6 分またはそれ以前（5 分後まで）に発生した場合は一致と見なされます。ちょうど指定した時間である場合も一致と見なされます。

### Within 演算子と After 演算子 {#within_after}

[!UICONTROL Within] と [!UICONTROL After] を使用して、フィルターの両端に最大および最小のエンドポイントを設定します。

**例**：訪問者がページ A に訪問し、2 週間後以降、1 ヶ月以内にページ B に訪問した。

![](assets/time_between_using_both_operators.png)

**セグメントの作成**:[!UICONTROL  訪問者 ] コンテナ内の 2 つの [!UICONTROL  ヒット ] コンテナを順序付けして、フィルターを作成します。 次に、[!UICONTROL After] 演算子と [!UICONTROL Within] 演算子を設定します。

![](assets/within_after_together.png)

**一致する**

2019 年 6 月 1 日にページ A にアクセスした訪問者が 2019 年 6 月 15 日（PT）以降 00:01 に戻りますが、*それ以前* 2019 年 7 月 1 日（PT）がフィルターに含まれます。 「除外間の時間」の節と比較してください。

[!UICONTROL After] 演算子と [!UICONTROL Within] 演算子を組み合わせて使用し、順次フィルターを定義できます。

![](assets/time_between_within_after.png)

この例では、2 回目の訪問で 2 週間後から 1 ヶ月までの間にページ B にヒットしています。
